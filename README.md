
# JSON Parser

**Project Name**: JSON Parser  
**Author**: Adithya Olivannan
**Language**: Python  
**Platform**: Linux (other OS's may require adjustments to paths in `main.py`)  

---

## Project Structure

```
Olivannan/
├── docs/
│   └── Documentation/
├── output/
│   ├── tokenizedOutput.txt
│   ├── parsedOutput.txt
│   └── AST.txt
├── res/
│   ├── error_files/
│   │   ├── type1Error.txt
│   │   ├── type2Error.txt
│   │   ├── type3Error.txt
│   │   ├── type4Error.txt
│   │   ├── type5Error.txt
│   │   ├── type6Error.txt
│   │   └── type7Error.txt
│   ├── errorless_files/
│   │   ├── file1.txt
│   │   ├── file2.txt
│   │   └── file3.txt
│   └── sampleJSON.txt
├── src/
│   ├── DFA.py
│   ├── ParseTree.py
│   └── main.py
├── README.md
└── reflection.txt
```

---

The documentation is inside the `docs` folder in PDF format.

## Overview

This project builds on the JSON Parser by adding a JSON parser with semantic analysis capabilities. The parser reads tokens generated by the DFA (scanner) and checks for both syntax and semantic correctness according to JSON rules. In addition to standard JSON validation, the parser performs semantic checks, including:

- Detection of invalid decimal numbers (e.g., "3." or ".14").
- Detection of empty dictionary keys (e.g., `""` or `" "`).
- Detection of reserved words as dictionary keys or strings (e.g., `true`, `false`, `null`).
- Detection of duplicate keys in dictionaries.
- Detection of inconsistent types in list elements.

Errors are raised for invalid semantic structures, ensuring that the input adheres to not only the syntactical but also the semantic rules of JSON.


## Usage

### How to Run the Parser

1. **Install Python**:
   - Ensure Python 3.x is installed on your system. You can check your Python version by running:
     ```bash
     python3 --version
     ```

2. **Navigate to the `src` Directory**:
   - Open your terminal and navigate to the `src` directory within the `Olivannan` folder:
     ```bash
     cd path/to/Olivannan/src
     ```

3. **Provide JSON Input**:
   - Place your JSON data in the `sampleJSON.txt` file located in the `res` directory. You can edit it using any text editor:
     ```bash
     nano ../res/sampleJSON.txt
     ```

4. **Run the Parser**:
   - Execute the `main.py` script to run the scanner and parser:
     ```bash
     python3 main.py
     ```

5. **View the Output**:
   - The tokenized output will be stored in `output/tokenizedOutput.txt`, the parsed structure will be in `output/parsedOutput.txt` and the AST will be in `output/AST.txt` To view the parsed output, use:
     ```bash
     cat ../output/parsedOutput.txt
     ```

---

## Assumptions Made

- **Input JSON in `sampleJSON.txt`**:  
  The program assumes that the JSON data to be parsed is located in the `res/sampleJSON.txt` file.
- **JSON Well-Formatted**:  
  The parser handles syntax validation but expects a standard JSON structure and may report errors for irregular formats or non-standard syntax.
- **Pathing**:  
  Paths are set up for Linux. Adjustments to file paths may be needed for other operating systems.

---

## Code Structure and Explanation

### DFA Design (`DFA.py`):
- This module contains the implementation of the Deterministic Finite Automaton (DFA) used for tokenizing JSON input.
- The DFA functions define various states (e.g., `S0`, `STRING`, `NUMBER`) and transitions between them based on the characters encountered in the input.
- The `tokenize()` function reads characters, invokes state functions, and returns the list of tokens.

### Parser Module (`ParseTree.py`)

The `Parser.py` file contains the main parser class, which validates JSON structure by analyzing the token sequence output by `DFA.py`.

#### Main Components:

1. **Parser Class**: 
   - **Methods**:
     - `parse_dict()`: Validates JSON objects by checking that keys are strings and key-value pairs are separated by colons and commas.
     - `parse_list()`: Parses JSON arrays, ensuring that elements are separated by commas.
   - **Error Handling**: Detects and raises errors for syntax mismatches (e.g., missing commas, brackets, braces, or invalid token sequences).

2. **Parser Execution**:
   - Reads tokens generated by the DFA, then recursively checks each token sequence to validate JSON structure.
   - Writes parsed structure to `output/parsetree.txt`.
   - Throws errors if errors were encountered when parsing JSON

3. **Semantic Analysis**:
    - In addition to syntax checking, the parser also performs semantic checks:
        - **Invalid Decimal Numbers**: Detects malformed numbers like `"3."` or `".14"`.
        - **Empty Dictionary Keys**: Flags empty or whitespace-only dictionary keys.
        - **Reserved Words as Keys/Strings**: Flags usage of `true`, `false`, or `null` as dictionary keys or string values.
        - **Duplicate Keys in Dictionaries**: Flags duplicate keys within objects.
        - **Inconsistent Types in Lists**: Flags lists where elements are of inconsistent types.
    - Writes the AST to `output/AST.txt`


### Error Handling
  The scanner includes mechanisms to handle various types of errors:
- **Invalid Characters**: Characters that are not part of the JSON specification will raise errors.
- **Malformed Strings/Numbers**: Issues like unclosed strings or invalid number formats are caught and reported.
  - Errors are written directly to the console for easy debugging.
  The parser handles multiple JSON syntax errors:
- **Unexpected Tokens**: Errors if tokens do not follow JSON structure (e.g., missing commas).
- **Mismatched Brackets/Braces**: Checks for correct closing of braces and brackets.
- **Type Errors**: Ensures JSON values are of valid types and correctly placed (e.g., no numbers as keys in objects).

---

## Example Input and Output

1. **Example Input (`sampleJSON.txt`)**:
   ```json
   {
       "name": "Olivannan",
       "age": 25,
       "isStudent": true,
       "courses": ["CSCI1110", "CSCI1105"],
       "address": {
           "city": "Halifax",
           "postalCode": "B3H1W5"
       },
       "graduated": null
   }
   ```

2. **Expected Tokenized Output (`tokenizedOutput.txt`)**:
   ```
   LBRACE
   STRING: name
   COLON
   STRING: Olivannan
   COMMA
   STRING: age
   COLON
   NUMBER: 25
   COMMA
   STRING: isStudent
   COLON
   BOOL: true
   COMMA
   STRING: courses
   COLON
   LBRACKET
   STRING: CS101
   COMMA
   STRING: CS102
   RBRACKET
   COMMA
   STRING: address
   COLON
   LBRACE
   STRING: city
   COLON
   STRING: Halifax
   COMMA
   STRING: postalCode
   COLON
   STRING: B3H1W5
   RBRACE
   COMMA
   STRING: graduated
   COLON
   NULL
   RBRACE
   ```

3. **Expected Parsed Output (`parsetree.txt`)**:
   ```
   - Node: StartOfParseTree
   - Node: dict
       - Leaf: {
       - Leaf: STRING
       - Leaf: :
       - Leaf: STRING
       - Leaf: ,
       - Leaf: STRING
       - Leaf: :
       - Leaf: NUMBER
       - Leaf: ,
       - Leaf: STRING
       - Leaf: :
       - Leaf: KEYWORD
       - Leaf: ,
       - Leaf: STRING
       - Leaf: :
       - Node: list
           - Leaf: [
           - Leaf: STRING
           - Leaf: ,
           - Leaf: STRING
           - Leaf: ]
       - Leaf: ,
       - Leaf: STRING
       - Leaf: :
       - Node: dict
           - Leaf: {
           - Leaf: STRING
           - Leaf: :
           - Leaf: STRING
           - Leaf: ,
           - Leaf: STRING
           - Leaf: :
           - Leaf: STRING
           - Leaf: }
       - Leaf: ,
       - Leaf: STRING
       - Leaf: :
       - Leaf: KEYWORD
       - Leaf: }

      ```

4. **Expected AST (`AST.txt`)**:
   ```
   - Node: StartOfAST
   - Node: dict
     - Leaf: name
     - Leaf: Olivannan
     - Leaf: age
     - Leaf: 25
     - Leaf: isStudent
     - Leaf: TRUE
     - Leaf: courses
     - Node: list
       - Leaf: CSCI1110
       - Leaf: CSCI1105
     - Leaf: address
     - Node: dict
       - Leaf: city
       - Leaf: Halifax
       - Leaf: postalCode
       - Leaf: B3H1W5
     - Leaf: graduated
     - Leaf: NULL
    
     ```

### Error Example

If there’s a syntax error in the input:
   - **Input**:
     ```json
     {"name": "Olivannan", "age": 25, "isStudent" true}
     ```
   - **Expected Output**:
     ```
     Expected COLON after key in dict, found KEYWORD
     ```
     
If there’s a semantic error in the input:
   - **Input**:
       ```json
       {"name": "Olivannan", "age": 25, "isStudent": "true"}
       ```
   - **Expected Output**:
      ```
      Error type 7 at true : Reserved words as string
      ```
---

## Additional Notes

- **Customization**: Modify `sampleJSON.txt` for testing the parser with different JSON structures.
- **Cross-Platform Use**: Paths are Linux-based; modify for Windows/macOS if needed.
- **Improvements**: Additional JSON-specific error messages or optimizations could improve readability and performance for large files.

--- 

This `README` provides an overview of both the tokenization and parsing processes, intended to guide further development and usage of the JSON parser project.
